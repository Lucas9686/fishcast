---
phase: 06-offline-enhancement
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - fishing-app/manifest.json
  - fishing-app/js/storage.js
  - fishing-app/js/app.js
  - fishing-app/images/icon-192.png
  - fishing-app/images/icon-512.png
autonomous: false

must_haves:
  truths:
    - "User can install app as PWA from browser on mobile (Android Chrome shows install prompt)"
    - "User sees storage usage display in app (e.g., 'Speicher: 12 MB / 500 MB')"
    - "App requests persistent storage so data is not evicted under storage pressure"
    - "User's last location and location history persist across sessions (already works, verified)"
  artifacts:
    - path: "fishing-app/manifest.json"
      provides: "PWA-compliant manifest with PNG icons and updated theme color"
      contains: "icon-192.png"
    - path: "fishing-app/images/icon-192.png"
      provides: "192x192 PNG icon for Android PWA install"
    - path: "fishing-app/images/icon-512.png"
      provides: "512x512 PNG icon for Android PWA splash screen"
    - path: "fishing-app/js/storage.js"
      provides: "Storage quota monitoring and cache clearing functions"
      contains: "checkStorageQuota"
    - path: "fishing-app/js/app.js"
      provides: "Storage quota display and persistent storage request on init"
      contains: "requestPersistentStorage"
  key_links:
    - from: "fishing-app/manifest.json"
      to: "fishing-app/images/icon-192.png"
      via: "icons array references PNG files"
      pattern: "icon-192\\.png"
    - from: "fishing-app/js/app.js"
      to: "fishing-app/js/storage.js"
      via: "calls checkStorageQuota and requestPersistentStorage on init"
      pattern: "checkStorageQuota"
---

<objective>
Make the app installable as a PWA with proper PNG icons, add storage quota monitoring to prevent exceeding device limits, and request persistent storage to protect user data from eviction.

Purpose: Users can install the app on their home screen for a native-like experience, and the app proactively manages storage to avoid data loss with 200+ fish species cached.
Output: PWA-installable manifest with PNG icons, storage quota UI, persistent storage request, human verification of install prompt.
</objective>

<execution_context>
@C:/Users/Lucas Benutzer/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Lucas Benutzer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-offline-enhancement/06-01-SUMMARY.md

@fishing-app/manifest.json
@fishing-app/js/storage.js
@fishing-app/js/app.js
@fishing-app/js/config.js
@fishing-app/images/icon.svg
</context>

<tasks>

<task type="auto">
  <name>Task 1: Generate PNG icons and update manifest for PWA installability</name>
  <files>fishing-app/manifest.json, fishing-app/images/icon-192.png, fishing-app/images/icon-512.png</files>
  <action>
**Part A: Generate PNG icons using raw binary (no npm dependencies)**

Run the following Node.js script to generate valid minimal PNG files with solid #0d1b2a fill. This uses ONLY Node.js built-in `zlib` and `fs` modules -- zero npm dependencies. Create the script as `fishing-app/generate-icons.js`, run it with `node fishing-app/generate-icons.js`, then delete the script.

```javascript
// generate-icons.js â€” Creates minimal valid PNG files with solid #0d1b2a fill
// Uses raw PNG binary format: signature + IHDR + IDAT (zlib-compressed) + IEND
// No npm dependencies required.

const fs = require('fs');
const zlib = require('zlib');
const path = require('path');

function createPNG(width, height, r, g, b) {
    // PNG signature (8 bytes)
    const signature = Buffer.from([137, 80, 78, 71, 13, 10, 26, 10]);

    // --- IHDR chunk ---
    const ihdrData = Buffer.alloc(13);
    ihdrData.writeUInt32BE(width, 0);   // width
    ihdrData.writeUInt32BE(height, 4);  // height
    ihdrData.writeUInt8(8, 8);          // bit depth: 8
    ihdrData.writeUInt8(2, 9);          // color type: 2 (RGB)
    ihdrData.writeUInt8(0, 10);         // compression: deflate
    ihdrData.writeUInt8(0, 11);         // filter: adaptive
    ihdrData.writeUInt8(0, 12);         // interlace: none
    const ihdr = makeChunk('IHDR', ihdrData);

    // --- IDAT chunk ---
    // Raw image data: each row = filter byte (0) + RGB pixels
    const rowSize = 1 + width * 3; // 1 filter byte + width * 3 color bytes
    const rawData = Buffer.alloc(rowSize * height);
    for (let y = 0; y < height; y++) {
        const offset = y * rowSize;
        rawData[offset] = 0; // filter type: None
        for (let x = 0; x < width; x++) {
            const px = offset + 1 + x * 3;
            rawData[px] = r;
            rawData[px + 1] = g;
            rawData[px + 2] = b;
        }
    }
    const compressed = zlib.deflateSync(rawData);
    const idat = makeChunk('IDAT', compressed);

    // --- IEND chunk ---
    const iend = makeChunk('IEND', Buffer.alloc(0));

    return Buffer.concat([signature, ihdr, idat, iend]);
}

function makeChunk(type, data) {
    const length = Buffer.alloc(4);
    length.writeUInt32BE(data.length, 0);
    const typeBuffer = Buffer.from(type, 'ascii');
    const crcInput = Buffer.concat([typeBuffer, data]);
    const crc = Buffer.alloc(4);
    crc.writeUInt32BE(crc32(crcInput), 0);
    return Buffer.concat([length, typeBuffer, data, crc]);
}

function crc32(buf) {
    // Standard CRC-32 (ISO 3309 / PNG spec)
    let crc = 0xFFFFFFFF;
    for (let i = 0; i < buf.length; i++) {
        crc ^= buf[i];
        for (let j = 0; j < 8; j++) {
            crc = (crc >>> 1) ^ (crc & 1 ? 0xEDB88320 : 0);
        }
    }
    return (crc ^ 0xFFFFFFFF) >>> 0;
}

// #0d1b2a = RGB(13, 27, 42)
const imagesDir = path.join(__dirname, 'images');
fs.mkdirSync(imagesDir, { recursive: true });

const png192 = createPNG(192, 192, 13, 27, 42);
fs.writeFileSync(path.join(imagesDir, 'icon-192.png'), png192);
console.log('Created icon-192.png (' + png192.length + ' bytes)');

const png512 = createPNG(512, 512, 13, 27, 42);
fs.writeFileSync(path.join(imagesDir, 'icon-512.png'), png512);
console.log('Created icon-512.png (' + png512.length + ' bytes)');
```

Steps:
1. Write the script above to `fishing-app/generate-icons.js`
2. Run: `node fishing-app/generate-icons.js`
3. Verify both PNG files were created (output shows byte sizes)
4. Delete the script: `rm fishing-app/generate-icons.js` (or `del` on Windows)

These are functional solid-color placeholder icons (dark marine #0d1b2a) that satisfy PWA install criteria. The user can replace them with designed icons later.

**Part B: Update manifest.json**

Replace the entire manifest.json with:

```json
{
    "name": "Petri Heil - Angel-Wetter & Fangprognose",
    "short_name": "Petri Heil",
    "description": "Angel-Wetter & Fangprognose App mit Solunar-Daten, Fischarten und 7-Tage Vorhersage",
    "start_url": "./index.html",
    "scope": "./",
    "display": "standalone",
    "orientation": "portrait-primary",
    "theme_color": "#0d1b2a",
    "background_color": "#0d1b2a",
    "lang": "de",
    "categories": ["weather", "sports"],
    "display_override": ["standalone", "minimal-ui"],
    "icons": [
        {
            "src": "images/icon.svg",
            "sizes": "any",
            "type": "image/svg+xml",
            "purpose": "any"
        },
        {
            "src": "images/icon-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "any"
        },
        {
            "src": "images/icon-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "images/icon-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "any"
        },
        {
            "src": "images/icon-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ],
    "shortcuts": [
        {
            "name": "Wetter pruefen",
            "short_name": "Wetter",
            "url": "./index.html#weather",
            "icons": [{"src": "images/icon-192.png", "sizes": "192x192", "type": "image/png"}]
        },
        {
            "name": "Fische suchen",
            "short_name": "Fische",
            "url": "./index.html#fish",
            "icons": [{"src": "images/icon-192.png", "sizes": "192x192", "type": "image/png"}]
        },
        {
            "name": "Favoriten",
            "short_name": "Favoriten",
            "url": "./index.html#favorites",
            "icons": [{"src": "images/icon-192.png", "sizes": "192x192", "type": "image/png"}]
        }
    ]
}
```

Key changes from current manifest:
- `theme_color` changed from `#1a5e2a` (old green) to `#0d1b2a` (dark marine theme)
- `background_color` changed from `#f0f4f0` to `#0d1b2a` (matches dark theme)
- Added PNG icon entries (192x192 and 512x512) with separate `any` and `maskable` purpose entries (per spec, purpose values should not be combined in a single entry)
- SVG icon purpose changed from `"any maskable"` to just `"any"` (SVG as maskable is unreliable)
- Added Favoriten shortcut (3rd tab)
- Shortcut URLs updated to use hash routing (`#weather`, `#fish`, `#favorites`) matching the hash router in app.js
- Shortcut icons now reference 192x192 PNG (more reliable than SVG for shortcuts)

NOTE: Do NOT split the `purpose: "any maskable"` on the SVG icon into two entries -- just change it to `"any"`. The SVG entry is for browsers that support SVG icons.
  </action>
  <verify>
1. Verify icon-192.png exists and is a valid PNG file: `file fishing-app/images/icon-192.png`
2. Verify icon-512.png exists and is a valid PNG file: `file fishing-app/images/icon-512.png`
3. Verify manifest.json has 5 icon entries (1 SVG + 2 PNG 192 + 2 PNG 512)
4. Verify theme_color is #0d1b2a
5. Verify 3 shortcuts defined
  </verify>
  <done>
- PNG icons at 192x192 and 512x512 exist as valid PNG files
- Manifest references all icons with correct sizes and purposes
- Theme colors match dark marine theme
- 3 shortcuts defined for all tabs
  </done>
</task>

<task type="auto">
  <name>Task 2: Add storage quota monitoring and persistent storage to storage.js and app.js</name>
  <files>fishing-app/js/storage.js, fishing-app/js/app.js</files>
  <action>
**Part A: Add storage functions to storage.js**

Add three new functions to storage.js (before the module.exports block):

```javascript
// ============================================================
// Speicher-Quota Monitoring
// ============================================================

/**
 * Checks storage quota usage
 * @returns {Promise<{usage: number, quota: number, percentage: number}|null>}
 */
async function checkStorageQuota() {
    if (!navigator.storage || !navigator.storage.estimate) {
        return null;
    }
    try {
        var estimate = await navigator.storage.estimate();
        var usage = estimate.usage || 0;
        var quota = estimate.quota || 0;
        var percentage = quota > 0 ? Math.round((usage / quota) * 100) : 0;
        return { usage: usage, quota: quota, percentage: percentage };
    } catch (e) {
        console.warn('Storage-Quota konnte nicht abgefragt werden:', e);
        return null;
    }
}

/**
 * Requests persistent storage to prevent data eviction
 * @returns {Promise<boolean>} true if storage is persistent
 */
async function requestPersistentStorage() {
    if (!navigator.storage || !navigator.storage.persist) {
        return false;
    }
    try {
        // Check if already persistent
        var isPersisted = await navigator.storage.persisted();
        if (isPersisted) return true;
        // Request persistence
        var granted = await navigator.storage.persist();
        return granted;
    } catch (e) {
        console.warn('Persistent Storage konnte nicht angefordert werden:', e);
        return false;
    }
}

/**
 * Clears API/weather cache (preserves user data like favorites, settings, history)
 * @returns {Promise<boolean>} true if caches were cleared
 */
async function clearApiCaches() {
    try {
        var cacheNames = await caches.keys();
        var apiCaches = cacheNames.filter(function(name) {
            return name.indexOf('petri-heil-api-') === 0;
        });
        await Promise.all(apiCaches.map(function(name) {
            return caches.delete(name);
        }));
        // Also clear weatherCache store in IndexedDB
        var db = await getDB();
        return new Promise(function(resolve, reject) {
            var tx = db.transaction('weatherCache', 'readwrite');
            var store = tx.objectStore('weatherCache');
            store.clear();
            tx.oncomplete = function() { resolve(true); };
            tx.onerror = function() { resolve(false); };
        });
    } catch (e) {
        console.warn('Cache leeren fehlgeschlagen:', e);
        return false;
    }
}
```

Update the module.exports block at the end of storage.js to include the new functions:
```javascript
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        initDB, addFavorite, removeFavorite, getFavorites, isFavorite,
        addToHistory, getHistory, saveSetting, getSetting,
        cacheWeatherData, getCachedWeather,
        checkStorageQuota, requestPersistentStorage, clearApiCaches
    };
}
```

**Part B: Add storage quota display and persistent storage request to app.js**

In the `init()` function of app.js, after the existing initialization code (after initDB is called), add:

```javascript
// Request persistent storage (silent, no user prompt needed)
requestPersistentStorage().then(function(persistent) {
    if (persistent) {
        console.log('Persistent Storage aktiv');
    }
});

// Display storage quota info
updateStorageDisplay();
```

Add a new function `updateStorageDisplay` inside the app.js IIFE:

```javascript
/**
 * Updates storage quota display in the favorites section
 */
async function updateStorageDisplay() {
    var quotaInfo = await checkStorageQuota();
    if (!quotaInfo) return;

    var storageEl = $('storage-info');
    if (!storageEl) return;

    var usageMB = (quotaInfo.usage / (1024 * 1024)).toFixed(1);
    var quotaMB = (quotaInfo.quota / (1024 * 1024)).toFixed(0);
    var text = 'Speicher: ' + usageMB + ' MB / ' + quotaMB + ' MB (' + quotaInfo.percentage + '%)';

    storageEl.textContent = text;

    // Warning states
    storageEl.classList.remove('storage-info--warning', 'storage-info--critical');
    if (quotaInfo.percentage >= 95) {
        storageEl.classList.add('storage-info--critical');
    } else if (quotaInfo.percentage >= 80) {
        storageEl.classList.add('storage-info--warning');
    }
}
```

Also add a `storage-info` display element. In the index.html, find the favorites section and add a small storage info line. OR, since we should minimize HTML changes, create the element dynamically in app.js:

In the init function, after DOM is ready, create the storage info element:

```javascript
// Create storage info display in favorites section
var favSection = $('section-favorites');
if (favSection) {
    var existingStorageInfo = $('storage-info');
    if (!existingStorageInfo) {
        var storageDiv = document.createElement('div');
        storageDiv.id = 'storage-info';
        storageDiv.className = 'storage-info';
        storageDiv.setAttribute('aria-label', 'Speicherverbrauch');
        // Insert at the end of favorites section
        favSection.appendChild(storageDiv);
    }
}
```

Add minimal CSS for storage info. Since we don't have a separate CSS task, inject it via a style element in app.js init, OR better: add it to css/style.css. Since style.css is not in our files_modified list and it's a small addition, add it inline in the created element's style:

Actually, add the styling directly via the className approach. The storageDiv will use these inline styles set via JS:

```javascript
storageDiv.style.cssText = 'padding: 0.75rem 1rem; font-size: 0.8rem; color: var(--text-secondary, #8899aa); text-align: center; opacity: 0.8;';
```

For warning/critical states in updateStorageDisplay:
```javascript
if (quotaInfo.percentage >= 95) {
    storageEl.style.color = '#ef4444';
    storageEl.textContent = text + ' - Speicher fast voll!';
} else if (quotaInfo.percentage >= 80) {
    storageEl.style.color = '#f59e0b';
    storageEl.textContent = text + ' - Speicher wird knapp';
} else {
    storageEl.style.color = 'var(--text-secondary, #8899aa)';
}
```

**Part C: Add cache clearing button in favorites section**

Create a "Cache leeren" button dynamically in app.js init, after the storage info display:

```javascript
var clearCacheBtn = document.createElement('button');
clearCacheBtn.id = 'btn-clear-cache';
clearCacheBtn.className = 'btn-clear-cache';
clearCacheBtn.textContent = 'Cache leeren';
clearCacheBtn.style.cssText = 'display: inline-block; margin: 0.5rem auto; padding: 0.4rem 1rem; font-size: 0.75rem; background: transparent; border: 1px solid var(--text-secondary, #8899aa); color: var(--text-secondary, #8899aa); border-radius: 0.5rem; cursor: pointer; opacity: 0.7;';
clearCacheBtn.addEventListener('click', async function() {
    clearCacheBtn.textContent = 'Wird geleert...';
    clearCacheBtn.disabled = true;
    var success = await clearApiCaches();
    clearCacheBtn.textContent = success ? 'Cache geleert!' : 'Fehler beim Leeren';
    setTimeout(function() {
        clearCacheBtn.textContent = 'Cache leeren';
        clearCacheBtn.disabled = false;
        updateStorageDisplay();
    }, 2000);
});

// Center container for both elements
var storageContainer = document.createElement('div');
storageContainer.style.cssText = 'text-align: center; padding: 1rem 0; border-top: 1px solid var(--border-color, #1a3a5c);';
storageContainer.appendChild(storageDiv);
storageContainer.appendChild(clearCacheBtn);
favSection.appendChild(storageContainer);
```

Adjust the earlier code: don't append storageDiv directly to favSection. Instead, create the container first, then append both storageDiv and clearCacheBtn to the container, then append the container to favSection.
  </action>
  <verify>
1. Check storage.js has checkStorageQuota, requestPersistentStorage, clearApiCaches functions
2. Check storage.js module.exports includes new functions
3. Check app.js calls requestPersistentStorage in init
4. Check app.js creates storage-info display element
5. Check app.js has updateStorageDisplay function
6. Check app.js has cache clearing button with click handler
  </verify>
  <done>
- checkStorageQuota returns {usage, quota, percentage} from navigator.storage.estimate()
- requestPersistentStorage called silently on init
- clearApiCaches clears API cache + weatherCache IndexedDB store (preserves favorites/settings/history)
- Storage quota displayed in favorites section with warning at 80% and critical at 95%
- "Cache leeren" button works and refreshes quota display after clearing
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify PWA installability and offline functionality</name>
  <files>fishing-app/index.html</files>
  <action>
Human verification of complete offline enhancement. No code changes needed -- this is a visual and functional check.

What was built:
- Service worker v6 with all fish images cached
- Offline/online banner detection
- Relative time weather timestamps
- PWA manifest with PNG icons
- Storage quota monitoring and cache clearing
- Location persistence via IndexedDB settings store

Steps to verify:

1. **PWA Install Test:** Open the app in Chrome. Look for the install icon in the address bar or the "Install" option in the browser menu. If not visible, open DevTools > Application > Manifest and check for any manifest errors. Confirm manifest shows 5 icons (1 SVG + 4 PNG) and no errors.

2. **Offline Test:** Open the app and let it load fully (wait for service worker to cache everything). Go to DevTools > Application > Service Workers, confirm "petri-heil-v6" is active. Enable "Offline" checkbox in DevTools > Network. Navigate to the Fish tab -- all fish cards should show their SVG images. Check that the offline banner appears at the top. Check that weather section shows "Letzte Aktualisierung: vor X Minuten/Stunden". Disable "Offline" -- banner should disappear.

3. **Storage Quota:** Navigate to Favorites tab, scroll to bottom. Should see "Speicher: X MB / Y MB (Z%)" and a "Cache leeren" button. Click "Cache leeren" and confirm it shows "Cache geleert!" then returns to normal state.

4. **Location Persistence (PWA-04 -- critical):** This is a dedicated test for the PWA-04 requirement. Perform ALL of the following steps:
   a. Select a specific location (e.g., "Wien" or any non-default location) using the location picker/dropdown.
   b. Verify the selected location is shown as active in the UI.
   c. Select 1-2 additional locations so they appear in location history.
   d. Close the browser tab completely (not just refresh -- actually close the tab).
   e. Reopen the app in a new tab.
   f. **Verify:** The last selected location (e.g., "Wien") is still selected and displayed, NOT reset to default.
   g. **Verify:** Open the location dropdown/history -- previously selected locations appear in the history list.
   h. Close the entire browser (all windows), reopen, navigate to the app.
   i. **Verify again:** Location is still persisted and history is intact.

5. **Offline + Location Persistence Combined:** Enable offline mode in DevTools. Verify the persisted location is still shown (location data comes from IndexedDB, not network).
  </action>
  <verify>User confirms all 5 success criteria pass: (1) fish catalog offline with images, (2) weather timestamp with relative time, (3) PWA installable, (4) location and location history persist across tab close AND browser restart, (5) storage quota display with cache clearing.</verify>
  <done>All Phase 6 success criteria verified by human testing, including explicit location persistence across sessions. Type "approved" or describe any issues found.</done>
</task>

</tasks>

<verification>
1. manifest.json has PNG icons at 192x192 and 512x512
2. PNG files exist at images/icon-192.png and images/icon-512.png
3. storage.js exports checkStorageQuota, requestPersistentStorage, clearApiCaches
4. app.js calls requestPersistentStorage on init
5. app.js shows storage quota in favorites section
6. app.js has "Cache leeren" button that clears API caches
7. Favorites, settings, and history are NOT cleared by cache clearing
8. Location persistence works (getSetting/saveSetting for lastLocation)
</verification>

<success_criteria>
- App is installable as PWA (Chrome shows install prompt or DevTools confirms installability)
- Storage quota is displayed to user with warning thresholds
- Persistent storage is requested on app init
- Cache clearing button removes API/weather caches but preserves user data
- All 5 phase success criteria are met
</success_criteria>

<output>
After completion, create `.planning/phases/06-offline-enhancement/06-02-SUMMARY.md`
</output>
